#!/usr/bin/env python

# Copyright 2013: Emmanouil Kiagias <e.kiagias@gmail.com>
# License: GPL

"""
This script generates the control file used by the Blend task package.
"""

import os
import sys
import argparse
import psycopg2
import logging
import pprint

#### UDD ####
UDDPORT=5452
DEFAULTPORT=5432

class UDD_connector:
    """
    This class connects with UDD and provides methods to query Blends' information
    """
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.connection = self.__get_db_connection()
        self.cursor = self.connection.cursor()

    def __get_db_connection(self):
        """
        Connects to UDD and return a cursor instance
        """
        ##TODO add additional connections in case of error (like different port)
        self.logger.debug("Trying to connect to UDD")
        try:
            conn = psycopg2.connect(host="localhost",port=UDDPORT,user="guest",database="udd")
        except psycopg2.OperationalError, err:
            try:
                conn = psycopg2.connect(host="udd.debian.org",port=UDDPORT,user="guest",database="udd")
            except psycopg2.OperationalError, err:
                self.logger.error("UDD connection error: {0}").format(err)
                sys.exit(-1)


        return conn

    def finish():
        """
        This method finalizes the db connection and the connected class' cursor
        """
        #FIXME add proper try catch
        self.cursor.close()
        self.connection.close()

    def __execute_query(self, query):
        """
        This function executes the given query and checks 
        if any error/exception occurs during the execution.
        """
        self.logger.debug("Executing query:\n{0}\n".format(query))

        try:
            self.cursor.execute(query)
        except psycopg2.ProgrammingError, err:
            self.logger.error("Problem with query\n{0}\n{1}".format(query, err))
            sys.exit(-1)
        except psycopg2.DataError, err:
            self.logger.error("{0}; query was\n{1}".format(err, query))
            sys.exit(-1)


    def get_available_releases(self):
        """
        It queries UDD and returns a list with with all the available releases(stable, testing etc)
        (for the moment is used for just checking the command line arguments, this function may be removed later)
        """
        query = "select distinct role from releases"

        self.__execute_query(query)

        #just check if any of the rows retured is empty
        return [ release[0] for release in self.cursor.fetchall() if release[0] ]

    def get_available_architectures(self):
        """
        It queries the UDD and returns a list with all the available Debian architectures
        """
        query = "select distinct architecture from packages"

        self.__execute_query(query)

        #just check if any of the rows retured is empty
        return [ arch[0] for arch in self.cursor.fetchall() if arch[0] ]

    def get_blend_info(self, blend):
        """
        Return a dictionary containing the given's blend info (title, description, vcs, taskprefix etc)
        """
        self.logger.debug("get_blend_info function was called")

        blend_info = {}    
        query="""
            SELECT * FROM blends_metadata WHERE blend='{0}'
            """.format(blend)

        self.__execute_query(query)

        #get the blend info from the cursor
        info = self.cursor.fetchone()

        ##TODO write a proper handling of invalid arguments(not existing blends, architecture etc)
        if not info:
            self.logger.error("Blend: {0} not found, aborting".format(blend))
            sys.exit(-1)

        #column name: 0 index of each desc list element
        desc = self.cursor.description

        for i, column in enumerate(desc):
            blend_info[column[0]] = info[i]

        return blend_info

    def __get_tasks_info(self, **kwargs):
        """
        Return a dictionary containing the tasks' info(title, description, section, priority etc) for the given blend
        """
        self.logger.debug("__get_task_info function was called")

        blendname = kwargs["blend"]
        tasksprefix = kwargs["tasksprefix"]
        release = kwargs["release"]

        blends_dependencies = {}

        query="""
            SELECT distinct t.task, t.description, t.metapackage, t.long_description,
              p.priority as "Priority", p.section as "Section", p.enhances as "Enhances"
                FROM blends_tasks t LEFT OUTER JOIN packages p ON  '{2}-' || t.task  = p.package 
                    LEFT OUTER JOIN releases r ON p.release = r.release
            WHERE t.blend='{0}' and (r.role = '{1}' or r.role is NULL )
            """.format(blendname, release, tasksprefix)

        self.__execute_query(query)

        desc = self.cursor.description

        #loop over each result in cursor's results set
        result = self.cursor.fetchone()

        while not result is None:
            #result row indexes: task(0), title(1), metapackage(2), description(3), long_description(4)
            task = result[0]

            blends_dependencies[task] = {}
            blends_dependencies[task]['haspackages'] = 0

            self.logger.debug("Reading info about task: {0}".format(task))

            #we want desc[1:] we dont want the 0 index which contains the task name
            #column[0] contains the column name(taken from cursor description)
            for i, column in enumerate(desc[1:]):
                #results[i+1] cause we start from index 1 (desc[1:]) and not from 0
                blends_dependencies[task][column[0]] = result[i+1]


            ##TODO: comment out
            #self.logger.debug(blends_dependencies[task])

            #also initialize empty lists for the following keys:
            for key in ["Depends", "Recommends", "Suggests", "Ignores"]:
                blends_dependencies[task][key] = []
                
            result = self.cursor.fetchone()
        
        return blends_dependencies

    ##FIXME: for the moment it returns a dataset even if an invalid architecture is provided cause inside
    #the sql query we select also the packages with architecture 'all', so (almost?)always it return some packages
    def get_blend_dependecies(self, **kwargs):
        """
        Using the given arguments queries UDD and returns a dictionary containing
        all the blends' tasks dependencies
        """
        blend = kwargs["blend"]
        release = kwargs["release"]
        architecture = kwargs["architecture"]
        nodepends = kwargs["nodepends"]

        self.logger.debug("get_blend_dependecies function was called.")

        #initialize the tasks' info before getting the dependencies for the tasks
        blend_dependencies = self.__get_tasks_info(blend = blend, release = release, tasksprefix = kwargs["tasksprefix"])
        available = []
        missing = []

        query = """
            SELECT b.task, b.package, b.dependency, b.distribution, pkg.component, pkg.architecture
              FROM blends_dependencies b LEFT OUTER JOIN ( 
                 SELECT p.package, p.distribution, p.component, p.architecture 
                   FROM all_packages p JOIN releases r ON p.release = r.release 
                   WHERE r.role='{1}' and architecture in ('{2}', 'all' )) pkg ON b.package = pkg.package
              WHERE b.blend='{0}'
              ORDER BY b.task
        """.format(blend, release, architecture)

        self.__execute_query(query)
        
        #indexes of row: task(0), package(1), dependency(2), distribution(3), component(4), architecture(5)
        row = self.cursor.fetchone()

        while not row is None:
            increase_packages = True
            #task, package, dependency, distribution, component, arch = (row[0], row[1], row[2], row[3], row[4], row[5])
            task, package, dependency, distribution, component, arch = row
            
            #TODO check again if: if else is with proper syntax
            if nodepends:
                #in this case all the Depends go to Recommends and the recommend packages
                #follow the same rules as the depends packages
                #dependency 'd'== depends and 'r' == recommends
                if dependency == 'd' or dependency == 'r':
                    if distribution == 'debian' and component == 'main' and not arch is None:
                        blend_dependencies[task]["Recommends"].append(package)
                    else:
                        blend_dependencies[task]["Suggests"].append(package)
            else:
                if dependency == 'd':
                    if distribution == 'debian' and component == 'main' and not arch is None:
                        blend_dependencies[task]["Depends"].append(package)
                    else:
                        blend_dependencies[task]["Suggests"].append(package)
                elif dependency == 'r':
                    blend_dependencies[task]["Recommends"].append(package)

            if dependency == 's':
                blend_dependencies[task]["Suggests"].append(package)
            if dependency == 'i':
                blend_dependencies[task]["Ignores"].append(package)
                missing.append(package)
                #TODO check again, here I imitate the old blends-dev load_task function
                increase_packages = False


            #not sure if i should add these packages into the missing
            if not distribution == 'debian' or not component == 'main' or arch is None:
                missing.append(package)
            else:
                available.append(package)

            if increase_packages:
               blend_dependencies[task]["haspackages"] += 1 

            row = self.cursor.fetchone()

        #return the depenencies with the corrensponding architecture
        return ({ "architecture" : architecture, "tasks" : blend_dependencies }, { "available" : available, "architecture" : architecture},
                     {"missing" : missing, "architecture" : architecture })


def gen_control(**kwargs):
    """
    This method generates the blend's control file using the dataDict which contains 
    the blends' info along with all the blends dependencies
    """
    logger = logging.getLogger(__name__)
    logger.debug("gen_control method was called")

    #get the data we need from kwargs
    hasconfig = kwargs["hasconfig"]
    suppressempty = kwargs["suppressempty"]
    nodepends = kwargs["nodepends"]
    tasksprefix = kwargs["blend_info"]["tasksprefix"]
    architecture = kwargs["blend_dependencies"]["architecture"]
    blend_dependencies = kwargs["blend_dependencies"]["tasks"]

    #TODO this is used for testing for the moment, will be changed
    control_path = "control/control.{0}".format(architecture)
    logger.debug("Opening file {0} to write".format(control_path))
    with open(control_path,'w') as fout:

        for task in sorted(blend_dependencies.keys()):
            
            if not blend_dependencies[task]["metapackage"]:
                continue

            logger.debug("{0}: {1}".format(task, blend_dependencies[task]["haspackages"]))

            #if no package was found in the target distribution suppress this task at all
            if suppressempty and blend_dependencies[task]["haspackages"] == 0:
                logger.debug("The metapackage {0} will not be created because {1} dependant are in the pool and suppressempty was set {2}".format(task, blend_dependencies[task]["haspackages"], suppressempty))
                continue

            fout.write("Package: {0}-{1}\n".format(tasksprefix, task))
            fout.write("Architecture: {0}\n".format(architecture))

            for header in ["Section", "Priority"]:
                if blend_dependencies[task][header]:
                    fout.write("{0}: {1}\n".format(header, blend_dependencies[task][header]))

            if nodepends:
                #Degrade dependencies to recommends
                fout.write("Depends: {0}-tasks (= ${{binary:Version}})".format(tasksprefix))

                if hasconfig:
                    fout.write(", {0}-config (= ${{binary:Version}})".format(tasksprefix))

                fout.write("\n")

                #TODO current blends-dev does a sort_uniq in case there are duplicates, also check if they exist
                fout.write("Recommends: {0}\n".format(",\n ".join(sorted(blend_dependencies[task]["Recommends"]))))

                if blend_dependencies[task]["Suggests"]:
                    fout.write("Suggests: {0}\n".format(",\n ".join(sorted(blend_dependencies[task]["Suggests"]))))

            else:
                for header in ["Depends", "Recommends", "Suggests"]:
                    if blend_dependencies[task][header]:
                        fout.write("{0}: {1}\n".format(header, ",\n ".join(sorted(blend_dependencies[task][header]))))

            fout.write("Description: {0}\n".format(blend_dependencies[task]["description"]))
            fout.write("{0}".format(blend_dependencies[task]["long_description"])) #Already contains a newline

            fout.write("\n")

def gen_task_desc(**kwargs):
    """
    This method generates the task description file for tasksel
    """
    logger = logging.getLogger(__name__)

    suppressempty = kwargs["suppressempty"]
    blend = kwargs["blend_info"]["blend"]
    tasksprefix = kwargs["blend_info"]["tasksprefix"]
    architecture = kwargs["blend_dependencies"]["architecture"]
    blend_dependencies = kwargs["blend_dependencies"]["tasks"]


    #TODO this is used for testing for the moment, will be changed
    task_desc_path = "taskdesc/{0}-tasks.desc.{1}".format(blend, architecture)
    logger.debug("Opening file {0} to write".format(task_desc_path))
    with open(task_desc_path,'w') as fout:

        for task in sorted(blend_dependencies.keys()):    

            if suppressempty and blend_dependencies[task]["haspackages"] == 0:
                logger.debug("The metapackage {2} will not be created because {0} dependant are in the pool and suppressempty was set {1}\n".format(blend_dependencies[task]["haspackages"], suppressempty, task))
                continue

            fout.write("Task: {0}-{1}\n".format(tasksprefix, task))
            fout.write("Section: {0}\n".format(blend));
            fout.write("Description: {0}\n".format(blend_dependencies[task]["description"]))
            fout.write("{0}".format(blend_dependencies[task]["long_description"])) #Already contains a newline
            fout.write("Relevance: 10\n")

            if blend_dependencies[task]["Enhances"]:
                fout.write("Enhances: {0}\n".format(blend_dependencies[task]["Enhances"]))

            if blend_dependencies[task]["metapackage"]:
                #No use listing a metapackage as a key package, if no metapackage exist.
                fout.write("Key: \n");
                fout.write(" {0}\n".format(tasksprefix, task))

            fout.write("Packages: list\n ")
            for header in ["Depends", "Recommends"]:
                fout.write("{0}".format("\n ".join(sorted(blend_dependencies[task][header]))))

            fout.write("\n\n")

def main():
    default_release = "testing"

    parser = argparse.ArgumentParser(epilog="Example: ./blend-gen-control -b debian-med -a amd64 --debug")
    #TODO this argument to be removed
    parser.add_argument("-b", "--blend", required=True, dest="blend", type=str,
                        help="Blend name")
    parser.add_argument("-r", "--release", dest="release", type=str, default=default_release,
                        help="Target release, eg: stable, testing etc, default is: testing")
    parser.add_argument("-D", dest="nodepends", action="store_true", default=False,
                        help="lower all Depends: to Recommends:")
    parser.add_argument("-S", dest="suppressempty", action="store_true", default=False,
                        help="suppress tasks without any recommended package")
    parser.add_argument("-c", dest="gencontrol", action="store_true", default=False,
                        help="Create new debian/control file.")
    parser.add_argument("-t", dest="taskdesc", action="store_true", default=False,
                        help="Print task descriptions and package list for task")
    parser.add_argument("-a", "--architecture", dest="architecture", type=str,
                        help="Target architecture, eg: i386, armel, amd64. If no architecture is provided,\
                         files will produced for all available Debian architectures")

    parser.add_argument("-d", "--debug", dest="debug", action="store_true", default=False,
                        help="Print debug information")
    #parse the command line arguments
    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig()
    logger = logging.getLogger(__name__)
    #----------------------------end of argparse and setup logging--------------------------------------#

    hasconfig = False
    config_file = "config/control"

    myudd = UDD_connector()


    #check if the arg release provided from the user is valid
    if not args.release  == default_release:
        if args.release not in myudd.get_available_releases():
            logger.error("Invalid release: {0}, aborting..".format(args.release))
            sys.exit(-1)

    available_architectures = myudd.get_available_architectures()

    #check if the user provided a single architecture , if not use all the available 
    if args.architecture:
        if args.architecture in available_architectures:
            architectures = [ args.architecture ]
        else:
            logger.error("Invalid architecture: {0}, aborting..".format(args.architecture))
            sys.exit(-1) 
    else:
        architectures = available_architectures

    #check if a config file exists
    if os.path.isfile(config_file):
        hasconfig = True

    #FIXME later on should be taken from the debian/control.stub file
    blendname = args.blend

    release = args.release
    suppressempty = args.suppressempty
    nodepends = args.nodepends

    blend_info = myudd.get_blend_info(blendname)
   
    if args.gencontrol:
        #generate a control for each provided architecture
        for arch in architectures:
            #get all the blends dependencies etc
            blend_dependencies, available, missing = myudd.get_blend_dependecies(blend = blend_info["blend"], release = release, 
                architecture = arch, tasksprefix = blend_info["tasksprefix"], nodepends = nodepends)
            
            gen_control(blend_info = blend_info, blend_dependencies = blend_dependencies,
                suppressempty = suppressempty, nodepends = nodepends, hasconfig = hasconfig)
    
    elif args.taskdesc:
        #generate a task description for each provided architecture
        for arch in architectures:
            #we reuse the same code as above here BUT we need the blend_dependencies here without nodepends so we make sure we call it
            #with nodepends = False no matter the command line argument, no need to descrease depends to recommends in any way for task description
            blend_dependencies, available, missing = myudd.get_blend_dependecies(blend = blend_info["blend"], release = release, 
                architecture = arch, tasksprefix = blend_info["tasksprefix"], nodepends = False)
            
            gen_task_desc(blend_info = blend_info, blend_dependencies = blend_dependencies,
                suppressempty = suppressempty)


    return 0

if __name__ == '__main__':
    main()