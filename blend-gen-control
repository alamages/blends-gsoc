#!/usr/bin/env python

# Copyright 2013: Emmanouil Kiagias <e.kiagias@gmail.com>
# License: GPL

"""
This script generates the control file used by the Blend task package.
"""

import sys
import argparse
import psycopg2
import json
import logging
import pprint

#### UDD ####
UDDPORT=5452
DEFAULTPORT=5432

class UDD_connector:
    """
    This class connects with UDD and provides methods to query Blends' information
    """
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.connection = self.__get_db_connection()
        self.cursor = self.connection.cursor()

    def __get_db_connection(self):
        """
        Connects to UDD and return a cursor instance
        """
        ##TODO add additional connections in case of error (like different port)
        self.logger.debug("Trying to connect to UDD")
        try:
            conn = psycopg2.connect(host="localhost",port=UDDPORT,user="guest",database="udd")
        except psycopg2.OperationalError, err:
            try:
                conn = psycopg2.connect(host="udd.debian.org",port=UDDPORT,user="guest",database="udd")
            except psycopg2.OperationalError, err:
                self.logger.error("UDD connection error: {0}").format(err)
                sys.exit(-1)


        return conn

    def finish():
        """
        This method finalizes the db connection and the connected class' cursor
        """
        #FIXME add proper try catch
        self.cursor.close()
        self.connection.close()

    def __execute_query(self, query):
        """
        This function executes the given query and checks 
        if any error/exception occurs during the execution.
        """
        self.logger.debug("Executing query:\n{0}\n".format(query))

        try:
            self.cursor.execute(query)
        except psycopg2.ProgrammingError, err:
            self.logger.error("Problem with query\n{0}\n{1}".format(query, err))
            sys.exit(-1)
        except psycopg2.DataError, err:
            self.logger.error("{0}; query was\n{1}".format(err, query))
            sys.exit(-1)


    def get_blend_info(self, blend):
        """
        Return a dictionary containing the given's blend info (title, description, vcs, taskprefix etc)
        """
        self.logger.debug("get_blend_info function was called")

        blend_info = {}    
        query="""
            SELECT * FROM blends_metadata WHERE blend='{0}'
            """.format(blend)

        self.__execute_query(query)

        #get the blend info from the cursor
        info = self.cursor.fetchone()

        ##TODO write a proper handling of invalid arguments(not existing blends, architecture etc)
        if not info:
            self.logger.error("Blend: {0} not found, aborting".format(blend))
            sys.exit(-1)

        #column name: 0 index of each desc list element
        desc = self.cursor.description

        for i, column in enumerate(desc):
            blend_info[column[0]] = info[i]

        ##TODO: comment out debug
        #self.logger.debug("Selected blend's info:")
        #self.logger.debug(pprint.pformat(blend_info, indent=4))

        return blend_info

    def __get_tasks_info(self, **kwargs):
        """
        Return a dictionary containing the tasks' info(title, description, section, priority etc) for the given blend
        """
        self.logger.debug("__get_task_info function was called")

        blendname = kwargs["blend"]
        tasksprefix = kwargs["tasksprefix"]
        release = kwargs["release"]

        blends_dependencies = {}

        query="""
            SELECT distinct t.task, t.description, t.metapackage, t.long_description, pkg.priority as "Priority", pkg.section as "Section" 
                FROM blends_tasks t LEFT OUTER JOIN 
                    (SELECT distinct p.package, p.priority, p.section 
                          FROM packages p JOIN releases r ON p.release = r.release
                      WHERE role='{1}') pkg ON  '{2}-' || t.task  = pkg.package
              WHERE t.blend='{0}'
            """.format(blendname, release, tasksprefix)

        self.__execute_query(query)

        desc = self.cursor.description

        #loop over each result in cursor's results set
        result = self.cursor.fetchone()

        while not result is None:
            #result row indexes: task(0), title(1), metapackage(2), description(3), long_description(4)
            task = result[0]

            blends_dependencies[task] = {}
            blends_dependencies[task]['haspackages'] = 0

            self.logger.debug("Reading info about task: {0}".format(task))

            #we want desc[1:] we dont want the 0 index which contains the task name
            #column[0] contains the column name(taken from cursor description)
            for i, column in enumerate(desc[1:]):
                #results[i+1] cause we start from index 1 (desc[1:]) and not from 0
                blends_dependencies[task][column[0]] = result[i+1]


            ##TODO: comment out
            #self.logger.debug(blends_dependencies[task])

            #also initialize empty lists for the following keys:
            for key in ["Depends", "Recommends", "Suggests", "Ignores"]:
                blends_dependencies[task][key] = []
                
            result = self.cursor.fetchone()
        
        return blends_dependencies

    ##FIXME: for the moment it returns a dataset even if an invalid architecture is provided cause inside
    #the sql query we select also the packages with architecture 'all', so (almost?)always it return some packages
    def get_blend_dependecies(self, **kwargs):
        """
        Using the given arguments queries UDD and returns a dictionary containing
        all the blends' tasks dependencies
        """
        blend = kwargs["blend"]
        release = kwargs["release"]
        architecture = kwargs["architecture"]
        nodepends = kwargs["nodepends"]

        self.logger.debug("get_blend_dependecies function was called.")

        #initialize the tasks' info before getting the dependencies for the tasks
        blend_dependencies = self.__get_tasks_info(blend = blend, release = release, tasksprefix = kwargs["tasksprefix"])
        missing = []

        query = """
            SELECT b.task, b.package, b.dependency, b.distribution, pkg.component, pkg.architecture
              FROM blends_dependencies b LEFT OUTER JOIN ( 
                 SELECT p.package, p.distribution, p.component, p.architecture 
                   FROM all_packages p JOIN releases r ON p.release = r.release 
                   WHERE r.role='{1}' and architecture in ('{2}', 'all' )) pkg ON b.package = pkg.package
              WHERE b.blend='{0}'
              ORDER BY b.task
        """.format(blend, release, architecture)

        self.__execute_query(query)
        
        #indexes of row: task(0), package(1), dependency(2), distribution(3), component(4), architecture(5)
        row = self.cursor.fetchone()

        while not row is None:
            increase_packages = True

            #TODO check again if: if else is with proper syntax
            if nodepends:
                #in this case all the Depends go to Recommends and the recommend packages
                #follow the same rules as the depends packages
                #dependency 'd'== depends and 'r' == recommends
                if row[2] == 'd' or row[2] == 'r':
                    #  distribution           component                architecture 
                    if row[3] == 'debian' and row[4] == 'main' and not row[5] is None:
                        #                  task                      package
                        blend_dependencies[row[0]]["Recommends"].append(row[1])
                    else:
                        blend_dependencies[row[0]]["Suggests"].append(row[1])
                        #add the package to the missing packages
                        missing.append(row[1])
            else:
                 #  dependency
                if row[2] == 'd':
                    #  distribution           component                architecture 
                    if row[3] == 'debian' and row[4] == 'main' and not row[5] is None:
                        #                  task                      package
                        blend_dependencies[row[0]]["Depends"].append(row[1])
                    else:
                        blend_dependencies[row[0]]["Suggests"].append(row[1])
                        #add the package to the missing packages
                        missing.append(row[1])
                elif row[2] == 'r':
                    blend_dependencies[row[0]]["Recommends"].append(row[1])

            if row[2] == 's':
                blend_dependencies[row[0]]["Suggests"].append(row[1])
            if row[2] == 'i':
                blend_dependencies[row[0]]["Ignores"].append(row[1])
                #TODO check again, here I imitate the old blends-dev load_task function
                missing.append(row[1])
                increase_packages = False

            if increase_packages:
               blend_dependencies[row[0]]["haspackages"] += 1 

            row = self.cursor.fetchone()
        
        ##TODO comment out
        #self.logger.debug("Dumping all task dependencies for {0} blend".format(blend))
        #self.logger.debug(pprint.pformat(blend_dependencies))

        #return the depenencies with the corrensponding architecture
        return ({ "architecture" : architecture, "tasks" : blend_dependencies }, {'missing' : missing, 'architecture' : architecture })


def gen_control(**kwargs):
    """
    This method generates the blend's control file using the dataDict which contains 
    the blends' info along with all the blends dependencies
    """
    logger = logging.getLogger(__name__)
    logger.debug("gen_control method was called")

    #get the data we need from kwargs
    hasconfig = kwargs["hasconfig"]
    supressempty = kwargs["supressempty"]
    nodepends = kwargs["nodepends"]
    tasksprefix = kwargs["blend_info"]["tasksprefix"]
    architecture = kwargs["blend_dependencies"]["architecture"]
    blend_dependencies = kwargs["blend_dependencies"]["tasks"]

    #TODO this is used for testing for the moment, will be changed
    control_path = "control/control.{0}".format(architecture)
    logger.debug("Opening file {0} to write".format(control_path))
    with open(control_path,'w') as fout:

        for task in sorted(blend_dependencies.keys()):
            
            if not blend_dependencies[task]["metapackage"]:
                continue

            logger.debug("{0}: {1}".format(task, blend_dependencies[task]["haspackages"]))

            #if no package was found in the target distribution suppress this task at all
            if supressempty and blend_dependencies[task]["haspackages"] == 0:
                logger.debug("The metapackage {0} will not be created because {1} dependant are in the pool and suppressempty was set {2}".format(task, blend_dependencies[task]["haspackages"], supressempty))
                continue

            fout.write("Package: {0}-{1}\n".format(tasksprefix, task))
            fout.write("Architecture: {0}\n".format(architecture))

            for header in ["Section", "Priority"]:
                if blend_dependencies[task][header]:
                    fout.write("{0}: {1}\n".format(header, blend_dependencies[task][header]))

            if nodepends:
                #Degrade dependencies to recommends
                fout.write("Depends: {0}-tasks (= ${{binary:Version}})".format(tasksprefix))

                if hasconfig:
                    fout.write(", {0}-config (= ${{binary:Version}})".format(tasksprefix))

                fout.write("\n")

                #TODO current blends-dev does a sort_uniq in case there are duplicates, also check if they exist
                fout.write("Recommends: {0}\n".format(",\n ".join(sorted(blend_dependencies[task]["Recommends"]))))

                if blend_dependencies[task]["Suggests"]:
                    fout.write("Suggests: {0}\n".format(",\n ".join(sorted(blend_dependencies[task]["Suggests"]))))

            else:
                for header in ["Depends", "Recommends", "Suggests"]:
                    if blend_dependencies[task][header]:
                        fout.write("{0}: {1}\n".format(header, ",\n ".join(sorted(blend_dependencies[task][header]))))

            fout.write("Description: {0}\n".format(blend_dependencies[task]["description"]))
            fout.write("{0}".format(blend_dependencies[task]["long_description"])) #Already contains a newline

            fout.write("\n")

def main():
    parser = argparse.ArgumentParser(epilog="Example: ./blend-gen-control -b debian-med -a amd64 --debug")
    #TODO this argument to be removed
    parser.add_argument("-b", "--blend", required=True, dest="blend", type=str,
                        help="Blend name")
    parser.add_argument("-r", "--release", dest="release", type=str, default="testing",
                        help="Target release, eg: stable, testing etc, default is: testing")
    parser.add_argument("-D", dest="nodepends", action="store_true", default=False,
                        help="lower all Depends: to Recommends:")
    parser.add_argument("-S", dest="supressempty", action="store_true", default=False,
                        help="suppress tasks without any recommended package")
    parser.add_argument("-c", dest="gencontrol", action="store_true", default=False,
                        help="Create new debian/control file.")
    #TODO this argument to be removed
    parser.add_argument("-a", "--architecture", required=True, dest="architecture", type=str,
                        help="Target architecture, eg: i386, armel, amd64")

    parser.add_argument("-d", "--debug", dest="debug", action="store_true", default=False,
                        help="Print debug information")
    #parse the command line arguments
    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig()

    logger = logging.getLogger(__name__)

    ##FIXME write a proper handling of invalid arguments(not existing blends, architectures, releases etc)
    #for example all available roles(stable etc) should be taken from UDD, also the same goes for blends etc
    #just a simple check for the moment
    if args.release not in ['stable', 'testing', 'unstable']:
        logger.error("Invalid release: {0}, aborting..".format(args.release))
        sys.exit(-1)

    myudd = UDD_connector()

    #FIXME must check in the blends directory for(taken from current blends-dev):
    #if  ( -d "config" && -e "config/control" ) 
    hasconfig = False

    #later on should be taken from the debian/control.stub file
    blendname = args.blend
    release = args.release
    supressempty = args.supressempty
    nodepends = args.nodepends

    #TODO you add a loop for each debian architecture
   
    architecture = args.architecture

    blend_info = myudd.get_blend_info(blendname)

    blend_dependencies, missing = myudd.get_blend_dependecies(blend = blend_info["blend"], release = release, 
        architecture = architecture, tasksprefix = blend_info["tasksprefix"], nodepends = nodepends)

    #not functional yet
    if args.gencontrol:
        gen_control(blend_info = blend_info, blend_dependencies = blend_dependencies,
            supressempty = supressempty, nodepends = nodepends, hasconfig = hasconfig)

    ##TODO the rest

    return 0

if __name__ == '__main__':
    main()